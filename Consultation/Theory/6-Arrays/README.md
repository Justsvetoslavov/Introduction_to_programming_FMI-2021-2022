# Масиви (с фиксирана дължина)

**Масивът** е наредена последователност от елементи от един тип.
Отделен елемент на масива се достъпва посредством името на масива, последвано от поредния номер (индекс) на елемента в квадратни скоби.

**Инициализация на масиви**

   ```c++
    int arr[6]; // Създава масив от 6 елемента, всеки от които е цяло число.
    int arr2[] = {0, 1, 2, 3, 4, 5}; // Създава масив от 6 елемента.
    int arr3[6] = {1,2,3}; //Останалите елементи се запълват с defaut-на стойност. 
    int arr[]; //грешка
    int arr[4] = {1, 2, 3, 4, 5} // грешка
```

Задължително големината на масива трябва да е константа, чиято стойност е ясна преди да се компилира програмата

```c++
	int n;
	cin >> n;
	int arr[n]; //грешка!
```

```c++
	const int SIZE = 4;
	int arr[SIZE]; //ok!
```

**Достъп на елемент**
В масивите имаме константен достъп до всеки един елемент.    
Достъпът става посредством индекси.     
Индексацията започва от 0. (защо?)     

```c++
int arr[] = {1, 2, 400, 4, 5}
arr[3] = 44; //Присвоява на елементът на индекс 3 стойността 44.
             // [1, 2, 400, 44, 5]
cout << arr[2]; //Отпечатва на стандартния изход елементът на индекс 2 (400)
   
```
arr не е самият масив, а указател към първия елемент.
   ```c++
   int arr[] = {1, 2, 400, 4, 5}
	cout << arr; //ще се отпечата АДРЕСА на масива, но не и самия масив.
```

Достъпът до елемент става, чрез смятането адреса му:

Адресът на arr[i] е: arr + i * sizeof(type of array)

i е брой "отмествания" надясно.

**Подаване на масиви във функции**
```c++
#include <iostream>
using namespace std;

void print(const int arr[], int len)
{
	for(int i = 0; i < len; i++)
		cout << arr[i] << " ";
}

void increment(int[] arr, unsigned size)
{
	for(unsigned i = 0; i < size; i++)
		arr[i]++;
}

int main()
{
	const int SIZE = 4;
	int arr[SIZE] {1,2,3,4};
	
	increment(arr, SIZE);
	print(arr,SIZE);
    
	return 0;
}
```

Масивите се подават във функциите по адрес! 
Т.е промените, които се правят върху масива във функцията, ще се отразят върху подадения като параметър масив!

# Многомерни масиви

**Двумерни масиви**

```c++
int matrix1[3][4]; // създава се матрица с 3 реда и 4 колони

int arr[3][4] = { { 1, 2, 3, 4 }, { 9, 8, 7, 6 }, { 11, 12, 13, 14 } }; // изреждаме редовете

int matrix3[3][4] = { 1, 2, 3, 4, 9, 8, 7, 6, 11, 12, 13, 14 }; // изреждаме елементите

int matrix4[][4] = { 1, 2, 3, 4, 9, 8, 7, 6, 11, 12, 13, 14 }; // можем да изпуснем най-лявата спецификация на дължина

```

**Достъп до елемент**
 ```c++
 int* row = arr[1]; //ред 1 (масивът на индекс 1)
 std::cout << arr[2][0]<< std::endl //11;
 std::cout << row[2]<< std::endl //7;
```

**Примери с n-мерни масиви**

```c++
 int cube[3][3][3]; // създава се тримерен масив  
```
 ### Достъп до елемент.

```c++
 cube[2]    // двумерен масив;
 cube[2][1] // едномерен масив;
 cube[2][1][4] // конкретен елемент;

```

# Динамична памет

**Stack**
- паметта се заделя ПРЕДИ да се компилира програмата.
- паметта се освобождава/трие/маркира като свободна автоматично - при излизането от scope-а,  в който е дефинирана.

**Heap** 
 - Масиви и обекти без предварително да е известна големината.
 - Памет(заделена) по време на изпълнение на програмата.

Оператор **new**
- Връща указтел към началото на паметта

```c++
new int[n];  n НЕ е задължително да е константа!
```

Заделянето на динамична памет е много "бавна" операция!!
Динамична памет НЕ се трие автоматично.

**Оператор delete[]** 
- освобождава/маркира като свободна динамична памет!

```c++
void f()
{
  int x = 40;
  char ch[2] = {'a', 'b'};
  int* ptr = new int[3];
}
```

След приключването на функцията ще се изчисти паметта в стека, но НЕ и паметта в heap-а.
За това ние трябва ръчно да я маркираме като свободна.

```c++
void f()
{
  int x = 40;
  char ch[2] = {'a', 'b'};
  int* ptr = new int[3];
  delete[] ptr; //!!!!!!!
}
```
